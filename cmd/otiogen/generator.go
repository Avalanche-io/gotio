// SPDX-License-Identifier: Apache-2.0
// Copyright Contributors to the OpenTimelineIO project

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
	"unicode"
)

// Generator generates encoder/decoder code for OTIO types.
type Generator struct {
	encoderTmpl *template.Template
	decoderTmpl *template.Template
}

// NewGenerator creates a new code generator.
func NewGenerator() (*Generator, error) {
	funcMap := template.FuncMap{
		"lower":      strings.ToLower,
		"title":      title,
		"schemaKey":  func(name string, version int) string { return fmt.Sprintf("%s.%d", name, version) },
		"hasPrefix":  strings.HasPrefix,
		"trimPrefix": strings.TrimPrefix,
		"isOpentime": func(t TypeDef) bool { return t.Package == "opentime" },
	}

	encoderTmpl, err := template.New("encoder").Funcs(funcMap).Parse(encoderTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse encoder template: %w", err)
	}

	decoderTmpl, err := template.New("decoder").Funcs(funcMap).Parse(decoderTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse decoder template: %w", err)
	}

	return &Generator{
		encoderTmpl: encoderTmpl,
		decoderTmpl: decoderTmpl,
	}, nil
}

func title(s string) string {
	if len(s) == 0 {
		return s
	}
	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

// GenerateOpenTimeEncoders generates encoders for opentime package types.
func (g *Generator) GenerateOpenTimeEncoders() ([]byte, error) {
	var buf bytes.Buffer

	data := struct {
		Package   string
		Types     []TypeDef
		IsEncoder bool
	}{
		Package:   "jsonenc",
		Types:     openTimeTypes,
		IsEncoder: true,
	}

	if err := g.encoderTmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

// GenerateOpenTimeDecoders generates decoders for opentime package types.
func (g *Generator) GenerateOpenTimeDecoders() ([]byte, error) {
	var buf bytes.Buffer

	data := struct {
		Package   string
		Types     []TypeDef
		IsDecoder bool
	}{
		Package:   "jsondec",
		Types:     openTimeTypes,
		IsDecoder: true,
	}

	if err := g.decoderTmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

// GenerateOTIOLeafEncoders generates encoders for leaf OTIO types.
func (g *Generator) GenerateOTIOLeafEncoders() ([]byte, error) {
	var buf bytes.Buffer

	data := struct {
		Package   string
		Types     []TypeDef
		IsEncoder bool
	}{
		Package:   "jsonenc",
		Types:     otioLeafTypes,
		IsEncoder: true,
	}

	if err := g.encoderTmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

// GenerateOTIOLeafDecoders generates decoders for leaf OTIO types.
func (g *Generator) GenerateOTIOLeafDecoders() ([]byte, error) {
	var buf bytes.Buffer

	data := struct {
		Package   string
		Types     []TypeDef
		IsDecoder bool
	}{
		Package:   "jsondec",
		Types:     otioLeafTypes,
		IsDecoder: true,
	}

	if err := g.decoderTmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

const encoderTemplate = `// Code generated by otiogen. DO NOT EDIT.
// SPDX-License-Identifier: Apache-2.0
// Copyright Contributors to the OpenTimelineIO project

package {{.Package}}

import (
	"reflect"

	{{- $hasOpentime := false}}
	{{- $hasOTIO := false}}
	{{- range .Types}}
	{{- if isOpentime .}}{{$hasOpentime = true}}{{end}}
	{{- if not (isOpentime .)}}{{$hasOTIO = true}}{{end}}
	{{- end}}
	{{- if $hasOpentime}}
	"github.com/Avalanche-io/gotio/opentime"
	{{- end}}
	{{- if $hasOTIO}}
	"github.com/Avalanche-io/gotio/opentimelineio"
	{{- end}}
)

{{range .Types}}
// encode{{.Name}} encodes a {{.Name}} to JSON.
func encode{{.Name}}(enc *Encoder, v any) error {
	{{- if isOpentime .}}
	t := v.(opentime.{{.Name}})
	{{- else}}
	t := v.(*opentimelineio.{{.Name}})
	{{- end}}
	enc.BeginObject()
	enc.WriteStringField("OTIO_SCHEMA", "{{.SchemaName}}.{{.SchemaVersion}}")
	{{- range .Fields}}
	{{- if eq .Kind 0}}{{/* FieldKindBasic */}}
	{{- if eq .GoType "string"}}
	enc.WriteStringField("{{.JSONName}}", t.{{title .Name}}())
	{{- else if eq .GoType "float64"}}
	enc.WriteFloat64Field("{{.JSONName}}", t.{{title .Name}}())
	{{- else if eq .GoType "bool"}}
	enc.WriteBoolField("{{.JSONName}}", t.{{title .Name}}())
	{{- else}}
	enc.WriteStringField("{{.JSONName}}", string(t.{{title .Name}}()))
	{{- end}}
	{{- else if eq .Kind 1}}{{/* FieldKindStruct */}}
	enc.WriteKey("{{.JSONName}}")
	{{- if hasPrefix .GoType "opentime."}}
	if err := encode{{trimPrefix .GoType "opentime."}}(enc, t.{{title .Name}}()); err != nil {
		return err
	}
	{{- else}}
	if err := encode{{.GoType}}(enc, t.{{title .Name}}()); err != nil {
		return err
	}
	{{- end}}
	{{- else if eq .Kind 2}}{{/* FieldKindPointer */}}
	{{- if .IsOptional}}
	if ptr := t.{{title .Name}}(); ptr != nil {
		enc.WriteKey("{{.JSONName}}")
		{{- if hasPrefix .GoType "*opentime."}}
		if err := encode{{trimPrefix .GoType "*opentime."}}(enc, *ptr); err != nil {
			return err
		}
		{{- else}}
		if err := EncodeValue(enc, ptr); err != nil {
			return err
		}
		{{- end}}
	} else {
		enc.WriteNullField("{{.JSONName}}")
	}
	{{- end}}
	{{- else if eq .Kind 6}}{{/* FieldKindAnyDict */}}
	if err := EncodeMetadata(enc, "{{.JSONName}}", t.Metadata()); err != nil {
		return err
	}
	{{- else if eq .Kind 4}}{{/* FieldKindSlice */}}
	enc.WriteKey("{{.JSONName}}")
	enc.BeginArray()
	{{- if eq .ElemType "*Marker"}}
	for i, item := range t.Markers() {
		if i > 0 {
			enc.WriteComma()
		}
		if err := encodeMarker(enc, item); err != nil {
			return err
		}
	}
	{{- else if eq .ElemType "Effect"}}
	for i, item := range t.Effects() {
		if i > 0 {
			enc.WriteComma()
		}
		if err := EncodeValue(enc, item); err != nil {
			return err
		}
	}
	{{- else}}
	for i, item := range t.{{title .Name}}() {
		if i > 0 {
			enc.WriteComma()
		}
		if err := EncodeValue(enc, item); err != nil {
			return err
		}
	}
	{{- end}}
	enc.EndArray()
	{{- end}}
	{{- end}}
	enc.EndObject()
	return nil
}

func init() {
	Register(TypeInfo{
		SchemaName:    "{{.SchemaName}}",
		SchemaVersion: {{.SchemaVersion}},
		{{- if isOpentime .}}
		GoType:        reflect.TypeOf(opentime.{{.Name}}{}),
		{{- else}}
		GoType:        reflect.TypeOf((*opentimelineio.{{.Name}})(nil)),
		{{- end}}
		Encode:        encode{{.Name}},
	})
}
{{end}}
`

const decoderTemplate = `// Code generated by otiogen. DO NOT EDIT.
// SPDX-License-Identifier: Apache-2.0
// Copyright Contributors to the OpenTimelineIO project

package {{.Package}}

import (
	"encoding/json"

	{{- $hasOpentime := false}}
	{{- $hasOTIO := false}}
	{{- range .Types}}
	{{- if isOpentime .}}{{$hasOpentime = true}}{{end}}
	{{- if not (isOpentime .)}}{{$hasOTIO = true}}{{end}}
	{{- end}}
	{{- if $hasOpentime}}
	"github.com/Avalanche-io/gotio/opentime"
	{{- end}}
	{{- if $hasOTIO}}
	"github.com/Avalanche-io/gotio/opentimelineio"
	{{- end}}
)

{{range .Types}}
{{- if isOpentime .}}
// {{lower .Name}}JSON is the JSON representation for decoding.
type {{lower .Name}}JSON struct {
	{{- range .Fields}}
	{{- if eq .GoType "RationalTime"}}
	{{title .Name}} opentime.RationalTime ` + "`" + `json:"{{.JSONName}}"` + "`" + `
	{{- else}}
	{{title .Name}} {{.GoType}} ` + "`" + `json:"{{.JSONName}}"` + "`" + `
	{{- end}}
	{{- end}}
}

// decode{{.Name}} decodes a {{.Name}} from JSON.
func decode{{.Name}}(data []byte) (any, error) {
	var j {{lower .Name}}JSON
	if err := json.Unmarshal(data, &j); err != nil {
		return nil, err
	}

	{{- if eq .Name "RationalTime"}}
	return opentime.NewRationalTime(j.Value, j.Rate), nil
	{{- else if eq .Name "TimeRange"}}
	return opentime.NewTimeRange(j.StartTime, j.Duration), nil
	{{- else if eq .Name "TimeTransform"}}
	return opentime.NewTimeTransform(j.Offset, j.Scale, j.Rate), nil
	{{- end}}
}
{{- else}}
// decode{{.Name}} decodes a {{.Name}} from JSON.
func decode{{.Name}}(data []byte) (any, error) {
	result := &opentimelineio.{{.Name}}{}
	if err := json.Unmarshal(data, result); err != nil {
		return nil, err
	}
	return result, nil
}
{{- end}}

func init() {
	Register(TypeInfo{
		SchemaName:    "{{.SchemaName}}",
		SchemaVersion: {{.SchemaVersion}},
		Decode:        decode{{.Name}},
	})
}
{{end}}
`
